# https://contest.yandex.ru/contest/27393/problems/E/
# E. Скорая помощь
import math

PATH = ""
INPUT_FILE = PATH + "input.txt"
OUTPUT_FILE = PATH + "output.txt"


# Читаем данные из input.txt
def load_data(filename):
    numbers = []
    with open(filename, "r") as file:
        numbers = map(int, file.readline().split())
    return numbers


# # Записываем результат в output.txt
def save_output(filename, result_data):
    with open(filename, "w") as file:
        file.write(result_data)


# Ищем этаж и подъезд искомого адреса
def calc_floor_entrance(k1, m, k2, p2, n2):
    '''
    входные данные
    :k1 - номер квартиры искомого адреса
    :m - всего этажей в доме
    :k2 - номер квартиры известного адреса
    :p2 - номер подъезда известного адреса
    :n2 - номер этажа известного адреса

    выходные данные
    :p1 - номер подъезда искомого адреса
    :n1 - номер этажа искомого адреса
    '''

    p1 = 0
    n1 = 0
    # Проверка на ошибочные данные
    # номер квартиры не может существовать с учетом этажности и номера подъезда, даже если на этаже по 1 квартире
    if k2 <= (p2 - 1) * m:
        return -1, -1
    # не может быть этажей в известном адресе больше чем общая этажность дома
    if n2 > m:
        return -1, -1
    # не может быть номер квартиры меньше этажа
    if k2 < n2:
        return -1, -1
    # для этажей начиная со 2го может быть ситуация, что квартиры впринципе не все могут быть попасть на заданном этаже
    # например на 3м этаже не может быть квартира 4, а на 4м этаже не могут быть кв:5,6, 9, на 5м: 6,7,8,11,12,16 и т.д.
    for i in range(n2 - 2, 0, -1):
        for j in range(n2 - 1 - i):
            if k2 == n2 * i + (j + 1):
                return -1, -1

    # Если этажность дома 1, то можно с увереностью сказать, что у искомого адреса 1ый этаж
    if m == 1:
        n1 = 1
    # Если номер искомой квартиры меньше/равен чем этажность дома то подъезд 1
    if k1 <= m:
        p1 = 1
    # Если квартира у известного адреса находится на 1 этаже, то действуют ограничения
    # 1. Могут быть случаяи когда не сможем определить подъезд искомой квартиры
    # 2. Исключение №1 если в подъезде только одна квартира
    # 3. Исключение №2 если искомая кв. < известной и известная на 1 этаже
    if n2 == 1:
        # но если в подъезде только одна квартира, тогда сможем
        if k2 == p2 and k2 != 1:
            p1 = k1
            n1 = 1
        # если искомая кв. < известной и известная на 1 этаже
        if k1 < k2 and p2 == 1 and n2 == 1:
            return 1, 1
        return p1, n1

    # кол-во квартрир на этаже (оно же минимально возможное кол-во квартир на этаже)
    flat_on_floor = math.ceil(k2 / ((p2 - 1) * m + n2))
    # максимально возможное кол-во квартир на этаже
    # min_flat_on_floor = math.ceil(k2 / ((p2 - 1) * m + n2))
    max_flat_on_floor = int(k2 / ((p2 - 1) * m + n2 - 1))

    p1 = math.ceil(k1 / (m * flat_on_floor))

    # квартира в подъезде
    number_flat_in_entrance = k1 - m * flat_on_floor * (p1 - 1)
    n1 = math.ceil(number_flat_in_entrance / flat_on_floor)
    #  Если квартиры известного адреса находится в 1 подъезде и этаж 1 или 2, а искомая квартира больше,
    #  то не можем определить этаж, т.к. кол-во квартир на этаже не может быть определено
    if p2 == 1 and k1 > k2 and n2 <= 2:
        n1 = 0

    # Если минимально и максимально возможное кол-во квартир различные и это влияет на результат тогда корректируем
    if flat_on_floor != max_flat_on_floor:
        # Если подъезды не совпадают для минимально и максимально возможного кол-во квартир, тогда неопределенность
        p1_max_flat = math.ceil(k1 / (m * max_flat_on_floor))
        if p1 != p1_max_flat:
            p1 = 0
        # Если этажи не совпадают для минимально и максимально возможного кол-во квартир, тогда неопределенность
        number_flat_in_entrance_max_flat = k1 - m * max_flat_on_floor * (p1 - 1)
        n1_max_flat = math.ceil(number_flat_in_entrance_max_flat / max_flat_on_floor)
        if n1 != n1_max_flat:
            n1 = 0



    # Если квартира у известного адреса равна этаж в квадрате, то кол-во квартир на этаже нельзя точно определить
    # Есть два варианта по кол-ву квартир, для n2=2 варианты кол.кв.на.этаже = 2/3, для n2=3 - 3/4, для n2=4 - 4/5...
    # Но если при обоих значенях кол-ва квартир в итоге подъезд искомого адреса равен, то это можно использовать
    if n2 ** 2 == k2:
        p1 = math.ceil(k1 / (m * n2))
        p1_shift = math.ceil(k1 / (m * (n2 + 1)))

        number_flat_in_entrance = k1 - m * n2 * (p1 - 1)
        number_flat_in_entrance_shift = k1 - m * (n2 + 1) * (p1_shift - 1)
        n1 = math.ceil(number_flat_in_entrance / n2)
        n1_shift = math.ceil(number_flat_in_entrance_shift / (n2 + 1))
        # Но если при обоих значенях кол-ва квартир в итоге подъезд искомого адреса равен, то это можно использовать
        if p1 != p1_shift:
            p1 = 0
        # Аналогично и этаж, в общем случае неизвестен, но если он совпадает для разных значений кол-ва квартир, хорошо
        if n1 != n1_shift:
            n1 = 0
    # Если известная и искомая это одна и та же квартира, то заполняем неопределенности
    if k1 == k2:
        if p1 == 0:
            p1 = p2
        if n1 == 0:
            n1 = n2
    return p1, n1


def main():
    # считываем входные данные
    k1, m, k2, p2, n2 = load_data(INPUT_FILE)
    # Ищем этаж и подъезд искомого адреса
    p1, n1 = calc_floor_entrance(k1, m, k2, p2, n2)
    # Записываем результат в output.txt
    save_output(OUTPUT_FILE, f"{p1} {n1}")


import pytest


@pytest.mark.parametrize(
    "numbers, target_solve",
    [
        ([89, 20, 41, 1, 11], (2, 3)),
        ([42, 20, 41, 1, 11], (1, 11)),
        ([45, 20, 41, 1, 11], (1, 12)),
        ([79, 20, 41, 1, 11], (1, 20)),
        ([80, 20, 41, 1, 11], (1, 20)),
        ([81, 20, 41, 1, 11], (2, 1)),
        ([11, 1, 1, 1, 1], (0, 1)),
        ([3, 2, 2, 2, 1], (-1, -1)),
        ([5, 20, 2, 1, 1], (1, 0)),
        ([11, 2, 4, 1, 2], (0, 2)),
        ([5, 20, 6, 1, 5], (-1, -1)),
        ([1000, 1, 449, 449, 1], (1000, 1)),
        ([40, 5, 60, 6, 5, ], (4, 5)),
        ([753, 10, 1000, 1, 1,], (1, 1)),
        ([31, 10, 4, 1, 2,], (2,0)),
        ([17, 10, 6, 1, 2,], (1,0)),
        ([842887, 10, 163729, 24, 8,], (123,0)),
        ([5, 1000, 5, 1, 2,], (1,2)),
        ([41, 10, 41, 1, 10,], (-1,-1))


    ]
)
def test_count_combination_queens(numbers, target_solve):
    p1, n1 = calc_floor_entrance(*numbers)
    assert (p1, n1) == target_solve


if __name__ == "__main__":
    main()
    pytest.main(args=[__file__])
    from line_profiler import LineProfiler

    lp = LineProfiler()
    lp_wrapper = lp(main)
    lp_wrapper()
    lp.print_stats()
